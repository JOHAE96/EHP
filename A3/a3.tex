
\documentclass[12pt,a4paper]{scrartcl}

\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{times}
\usepackage[T1]{fontenc} 
\usepackage[latin1]{inputenc} 
\usepackage[ngerman]{babel}
\usepackage[right=3cm]{geometry}
\usepackage{listings} % for code
\usepackage{tikz}

\parindent=0pt
\parskip=1em plus 2pt minus 1pt

\topskip-2cm
\textheight25cm
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\rhead{\thepage}

\begin{document}
\thispagestyle{empty}

\begin{center}
  \LARGE
  Praktische \"Ubungen - \\
  Experimentelle Hardwareprojekte \\
  \bigskip
  \Large 
  Versuchsprotokoll
\end{center}

\vspace{1em}
Versuch: A3 - Befehlssatzerweiterung und Test eines RISC-Prozessors

Versuchsdatum und -zeit: 21. Juni 2018, 10 Uhr - 13 Uhr

Betreuer: Andreas Reinsch

\vspace{1em}
Name, Studiengang, Mat.-Nr.: Alexander K\"uhnle, B.Sc. Informatik, 165692

Email: alexander.kuehnle@uni-jena.de

\vspace{1em}
Name, Studiengang, Mat.-Nr.: Mark Umnus, B.Sc. Informatik, 167419

Email: mark.umnus@uni-jena.de

\vspace*{1cm}
%% \mbox{}\\
\hrule
\vspace*{1cm}
{\Large  Eigenst\"andigkeitserkl\"arung }
 
Hiermit versichern wir, dass wir das Protokoll selbstst\"andig verfasst
und keine anderen Quellen und Hilfsmittel als die angegebenen benutzt 
haben. Im Falle einer Zuwiderhandlung erkennen wir an, dass unser Protokoll 
als nicht bestanden bewertet wird und damit das Modul ``Experimentelle 
Hardwareprojekte'' als nicht bestanden bewertet wird. \\
Dar\"uberhinaus ist uns klar, dass jede Zuwiderhandlung ausnahmslos dem 
Rechtsamt der FSU gemeldet wird, woraus weitere Konsequenzen resultieren 
k\"onnen. \\

Unterschriften: \\ 
\hspace*{4cm} ........................................ 
\hspace{2cm} ........................................  \\

\hrule

\vspace*{0.3cm}
\textbf{Vom Betreuer auszuf\"ullen:}

Vorbereitung/Kolloquium:

Durchf\"uhrung:

Protokoll:

Gesamtbewertung:
\clearpage


% Hier geht das Protokoll los...

\section{Vorbereitung}
Die wichtigste Grundlage zur Vorbereitung auf diesen Versuch war die Beschreibung des DLXJ-Prozessors, mit deren Hilfe wir uns verschiedene Konzepte klargemacht haben.

\subsection*{Befehlsstruktur}
Zuerst haben wir die Hexadezimaldarstellung von drei Kommandos betrachtet und diese decodiert.
Der erste Schritt dabei ist es, die Hex-Darstellung in eine Bin\"ardarstellung umzuwandeln, da die Argumente der Befehle nicht in Tetraden organisiert sind.
Der erste Befehl sieht dann folgenderma\ss en aus:
\begin{align*}
\text{0x50010003} & \equiv \underbrace{010100}_{OP-Code}\underbrace{00000}_{Rs1}\underbrace{00001}_{Rd}\underbrace{0000000000000011}_{Immediate} \\
\text{0x0021100C} & \equiv \underbrace{000000}_{OP-Code}\underbrace{00001}_{Rs1}\underbrace{00001}_{Rs2}\underbrace{00010}_{Rd}\underbrace{00000}_{unused}\underbrace{001100}_{rr\_func} \\
\text{0x00411809} & \equiv \underbrace{000000}_{OP-Code}\underbrace{00010}_{Rs1}\underbrace{00001}_{Rs2}\underbrace{00011}_{Rd}\underbrace{00000}_{unused}\underbrace{001001}_{rr\_func}
\end{align*}

Die Bin\"arbefehle wurden hier direkt interpretiert.
Dies geschah auf Grundlage des OP-Codes, der bei den letzten beiden Befehlen bestimmt, dass es sich um R-Typ-Befehle handelt, w\"ahrend der erste ein I-Typ-Befehl ist.
Auf die genaue Unterscheidung wird sp\"ater noch einmal eingegangen.
Zun\"achst werden die Befehle in Tabelle \ref{tab:vorbinstr} zur Veranschaulichung in Assemblercode zur\"uck\"ubersetzt und dann ausgewertet.

\begin{table}[h]
    \centering
    \begin{tabular}{l|l|l}
    \hline
    Befehl      & Assemblercode     & Registerinhalte nach Befehl           \\
    \hline
    0x50010003  & add.i r1, r0, 3   & R1 <- R0 + 3 = 0 + 3 = 3              \\
    0x0021100C  & sll   r2, r1, r1  & R2 <- R1 << R1 = 3 << 3 = 24          \\
    0x00411809  & or    r3, r2, r1  & R3 <- R2 $\vee$ R1 = 24 $\vee$ 3 = 27 \\
    \hline
    \end{tabular}
    \caption{Deassemblierte Befehle mit Registerupdates}
    \label{tab:vorbinstr}
\end{table}

\subsection*{R- und I-Befehlstypen}
Um in den n\"achsten Aufgaben die neuen Befehle implementieren zu k\"onnen, sollen hier kurz die Unterschiede zwischen R- und I-Typ-Befehlen erkl\"art werden.
Der erste Unterschied liegt im Befehlscodeformat.
W\"ahrend R-Typen zwei Quellregister und eine \texttt{rr\_func} angeben sowie einen Teil des Befehlscodes gar nicht nutzen, geben I-Typen ein Quellregister und eine 16-Bit-Konstante an.
Diese Unterscheidung ist jedoch f\"ur das Steuerwerk und auch f\"ur die ALU irrelevant.
Lediglich der Decoder 3 entscheidet auf dieser Basis, welcher Wert auf den S2-Bus gelegt werden soll - die Konstante oder ein Registerinhalt.
F\"ur die zu implementierenden Befehle bedeutet dies, dass jeweils nur ein neuer Zustand angelegt werden muss.

\subsection*{Erweiterung des Steuerwerks}
Wir haben also 5 neue Zust\"ande definiert: \texttt{add}, \texttt{and\_1}, \texttt{or\_1}, \texttt{sll\_1} und \texttt{srl\_1}, zu sehen auf Abbildung \ref{fig:fsm}.
Sie alle k\"onnen durch die Bedingung $(op\_rr\_func \wedge rr\_func\_***) \vee op\_***\_i$ vom Zustand \texttt{dec\_pcinc4\_ab} aus erreicht werden, wobei *** durch die jeweilige Befehlskennung zu ersetzen ist.
Ebenso f\"uhren alle neuen Zust\"ande nach der Abarbeitung des jeweiligen Befehls in den Zustand \texttt{wr\_back}.
Als Berechnung haben wir f\"ur einen Befehl \texttt{$C \leftarrow A \circ Y$} eingetragen, wobei A der Inhalt des Registers A ist und Y der Inhalt des Registers B oder ein Immediate-Wert, je nachdem, welcher Typ des Befehls vorliegt.
$\circ$ bezeichnet die jeweilige Operation.
Auf diese Weise haben wir auch den \texttt{sub}-Zustand angepasst.

\begin{figure}
    \begin{tikzpicture}[scale=3] 
        \path  (3, 2)  node[draw] (DEC) {dec\_pcinc4\_ab} 
               (1, 1.5)  node[draw,align=center] (ADD) {add \\ $C \leftarrow A + Y$}
               (2, 1.5)  node[draw,align=center] (AND) {and\_1 \\ $C \leftarrow A \wedge Y$}
               (3, 1.5)  node[draw,align=center] (OR)  {or\_1 \\ $C \leftarrow A \vee Y$}
               (4, 1.5)  node[draw,align=center] (SRL) {srl\_1 \\ $C \leftarrow A << Y$}
               (5, 1.5)  node[draw,align=center] (SLL) {sll\_1 \\ $C \leftarrow A >> Y$}
               (3, 1)  node[draw,align=center] (WRB) {wr\_back \\ $RD \leftarrow C$};
        \draw[->,gray] (DEC) --  (ADD.north);
        \draw[->,gray] (DEC) --  (AND.north);
        \draw[->,gray] (DEC) --  node[black] {$(op\_rr\_func \wedge rr\_func\_***) \vee op\_***\_i$} (OR.north);
        \draw[->,gray] (DEC) --  (SRL.north);
        \draw[->,gray] (DEC) --  (SLL.north);
        \draw[->] (ADD.south) -- (WRB);
        \draw[->] (AND.south) -- (WRB);
        \draw[->] (OR.south) -- (WRB);
        \draw[->] (SRL.south) -- (WRB);
        \draw[->] (SLL.south) -- (WRB);
        \draw (0.5, 0.8) -- (0.5, 2.2) -- (5.5, 2.2) -- (5.5, 0.8) -- (0.5, 0.8);
    \end{tikzpicture}
    \label{fig:fsm}
    \caption{Neue Zust\"ande der FSM des Steuerwerks}
\end{figure}

In all diesen neuen Zust\"anden (und \texttt{sub}) m\"ussen als Datenquellen die Signale \texttt{s1\_a} und \texttt{s2\_y} gew\"ahlt werden.
Als Datensenke wird jeweils \texttt{dest\_c} angesteuert.

\subsection*{VHDL-Erweiterung}
Im n\"achsten Schritt haben wir die gegebenen VHDL-Beschreibungen des Decoders 1, der Zustands\"uberf\"uhrungs- und der Ausgabefunktion erg\"anzt.
S\"amtliche Namen waren schon vordefiniert und mussten lediglich richtig eingesetzt werden.

\subsubsection*{Decoder 1}
Der Decoder 1 extrahiert die ALU-Operation aus dem Befehl.
Dazu gibt es zwei \texttt{case}-Statements:
Eines, in dem die letzten 6 Bit als RR-Funktion interpretiert werden und eines, bei dem direkt der OP-Code betrachtet wird.
Diese Konstellation f\"uhrt zu der bei Abbildung \ref{fig:fsm} genannten logischen Formel $(op\_rr\_func \wedge rr\_func\_***) \vee op\_***\_i$.
Unsere konkreten Erg\"anzungen sind in Listing \ref{lst:dec1} zu sehen.
Die Kommentare deuten dabei die umgebenen Codezeilen an.
\lstinputlisting[frame=single, label=lst:dec1, caption=Erg\"anzungen in \texttt{ir\_decode\_1-behavior.vhd}]{decoder1.vhd}

\subsection*{Assemblerprogramm}
Das Testprogramm besteht lediglich aus einer Aneinanderreihung der neuen Befehle.
Um den Code kleinzuhalten haben wir darauf verzichtet, die Ergebnisse auf dem Display auszugeben.
F\"ur die bessere \"Ubersicht \"uber die Resultate haben wir jedem Ergebnis ein eigenes Register zugewiesen.
So ist es im sp\"ateren Register Dump m\"oglich, das Programm auf Richtigkeit zu pr\"ufen.
Der Quellcode ist in Listing \ref{lst:test} dargestellt.
\lstinputlisting[label=lst:test, caption=Testprogramm, frame=single]{test.asm}

Auch nach der letzten Anweisung eines Programms wird der Befehlsz\"ahler des DLXJ-Prozessors weiter inkrementiert, es werden neue Speicherinhalte geladen und der Prozessor versucht, diese auszuf\"uhren.
Im g\"unstigsten Fall haben die Speicherinhalte ein ung\"ultiges Format und der Prozessor wechselt in den Error-State.
Es k\"onnten aber auch beliebige Befehle im Speicher stehen die ebenso beliebige Effekte h\"atten.
Um dies zu verhindern haben wir unser Programm mit einer Endlosschleife abgeschlossen.
Diese verhindert effektiv, dass der Befehlsz\"ahler hochz\"ahlt, da er immer auf das Label \texttt{end} zur\"uckgesetzt wird.

\section{Vorgehensweise}
In diesem Versuch wurden die zus\"atzlichen Befehle implementiert.
Anschlie\ss end wurde die Abarbeitung unseres Assemblerprogramms durch den DLXJ-Prozessor simuliert und auf dem Experimentalsystem getestet.

\section{Erprobung}
Dank unserer ausf\"uhrlichen Vorbereitung konnten wir unsere Aufgaben im Praktikum z\"ugig erledigen.
Zuerst haben wir die VHDL-Dateien des Decoders 1, der Zust\"ande und der \"Uberf\"uhrungsfunktion angepasst.
Dazu haben wir unseren Code an die bereits markierten Stellen kopiert.
Das \"Ubersetzen mit dem Programm NAME verlief fehlerlos.

Im Anschluss haben wir unser vorbereitetes Assemblerprogramm in den /asm-Ordner kopiert und \"ubersetzen lassen.
Mit dem Programm NAME konnten wir die Simulation des Assemblerprogramms starten.
Wir haben beobachtet, wie sich die Steuerleitungen LEITUNG1 und LEITUNG2 im Zeitverlauf verhalten.
Zudem haben wir die Zust\"ande des Steuerwerks protokolliert, die erwartungsgem\"a\ss\  dem Schema FETCH -> Befehl -> WRITE BACK folgten.
Die Registerbelegungen im Befehlsverlauf haben wir gedruckt; sie sind im Anhang xy zu finden.
Es traten keine \"Uberraschungen auf.


\section{Schlussfolgerungen}

\end{document}


